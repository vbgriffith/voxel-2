<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hollow Knight Type Game (Rooms, Enemies, Quests)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
  <style>
    body { margin: 0; background: #05060a; overflow: hidden; }
    canvas { display: block; margin: 0 auto; }
  </style>
</head>
<body>

<script>
/* -------------------------------------------------------
   SVG TEXTURES
------------------------------------------------------- */

const PLAYER_SVG = `
<svg width="64" height="64" xmlns="http://www.w3.org/2000/svg">
  <ellipse cx="32" cy="22" rx="14" ry="16" fill="white"/>
  <path d="M18 10 C10 0, 6 14, 14 22" fill="white"/>
  <path d="M46 10 C54 0, 58 14, 50 22" fill="white"/>
  <circle cx="26" cy="22" r="4" fill="black"/>
  <circle cx="38" cy="22" r="4" fill="black"/>
  <path d="M16 32 Q32 60 48 32 Q32 40 16 32" fill="black"/>
</svg>`;

const TILE_SVG = `
<svg width="64" height="32" xmlns="http://www.w3.org/2000/svg">
  <rect width="64" height="32" fill="#3a3a3a"/>
  <rect width="64" height="32" fill="none" stroke="#555" stroke-width="3"/>
  <rect width="64" height="32" fill="none" stroke="#222" stroke-width="1"/>
</svg>`;

const ENEMY_SVG = `
<svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
  <circle cx="20" cy="20" r="16" fill="#7b88ff"/>
  <circle cx="14" cy="18" r="4" fill="black"/>
  <circle cx="26" cy="18" r="4" fill="black"/>
</svg>`;

const NPC_SVG = `
<svg width="48" height="48" xmlns="http://www.w3.org/2000/svg">
  <rect x="10" y="10" width="28" height="28" rx="6" fill="#ffd27b"/>
  <circle cx="20" cy="22" r="3" fill="black"/>
  <circle cx="28" cy="22" r="3" fill="black"/>
  <path d="M18 30 Q24 34 30 30" stroke="black" stroke-width="2" fill="none"/>
</svg>`;


/* -------------------------------------------------------
   GAME CONFIG
------------------------------------------------------- */

const GAME_WIDTH = 960;
const GAME_HEIGHT = 540;

let cursors, attackKey, dashKey, interactKey;

class MainScene extends Phaser.Scene {
  constructor() { super('MainScene'); }

  preload() {
    this.svgTexture('player', PLAYER_SVG, 64, 64);
    this.svgTexture('tile', TILE_SVG, 64, 32);
    this.svgTexture('enemy', ENEMY_SVG, 40, 40);
    this.svgTexture('npc', NPC_SVG, 48, 48);
  }

  create() {
    cursors = this.input.keyboard.createCursorKeys();
    attackKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Z);
    dashKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.X);
    interactKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.C);

    this.physics.world.setBounds(0, 0, 4000, 2000);

    this.currentRoom = 'room1';
    this.rooms = this.buildRooms();

    this.platforms = this.physics.add.staticGroup();
    this.enemies = this.physics.add.group();
    this.doors = this.physics.add.staticGroup();
    this.npcs = this.physics.add.staticGroup();

    this.loadRoom(this.currentRoom);

    this.player = this.physics.add.sprite(200, 200, 'player');
    this.player.setCollideWorldBounds(true);
    this.player.setSize(24, 40).setOffset(20, 12);

    this.playerState = {
      canDoubleJump: true,
      isDashing: false,
      dashTime: 0,
      dashCooldown: 0,
      facing: 1,
      isAttacking: false,
      attackTime: 0,
      quest: {
        active: false,
        completed: false,
        targetRoom: 'room2',
        requiredKills: 3,
        currentKills: 0
      }
    };

    this.attackHitbox = this.physics.add.sprite(this.player.x, this.player.y, null);
    this.attackHitbox.body.setAllowGravity(false);
    this.attackHitbox.setSize(40, 20);
    this.attackHitbox.setVisible(false);

    this.physics.add.collider(this.player, this.platforms);
    this.physics.add.collider(this.enemies, this.platforms);

    this.physics.add.overlap(
      this.attackHitbox,
      this.enemies,
      (hitbox, enemy) => this.onEnemyHit(enemy),
      null,
      this
    );

    this.physics.add.overlap(
      this.player,
      this.doors,
      (player, door) => this.onDoorOverlap(door),
      null,
      this
    );

    this.physics.add.overlap(
      this.player,
      this.npcs,
      (player, npc) => this.onNpcOverlap(npc),
      null,
      this
    );

    this.cameras.main.setBounds(0, 0, 4000, 2000);
    this.cameras.main.startFollow(this.player, true, 0.1, 0.1);
    this.cameras.main.setZoom(2);

    this.questText = this.add.text(10, 10, '', {
      fontFamily: 'monospace',
      fontSize: '14px',
      color: '#ffffff'
    }).setScrollFactor(0);

    this.infoText = this.add.text(10, 30, '', {
      fontFamily: 'monospace',
      fontSize: '14px',
      color: '#aaaaaa'
    }).setScrollFactor(0);

    this.updateQuestUI();
  }

  update(time, delta) {
    const dt = delta / 1000;
    this.handleMovement(dt);
    this.handleJump();
    this.handleDash(dt);
    this.handleAttack(dt);
  }

  /* ---------------- Rooms & Layout ---------------- */

  buildRooms() {
    return {
      room1: {
        spawn: { x: 200, y: 200 },
        platforms: [
          { x: 0, y: 520, w: 4000 },
          { x: 400, y: 420 }, { x: 600, y: 360 }, { x: 800, y: 300 }
        ],
        enemies: [],
        doors: [
          { x: 3800, y: 480, targetRoom: 'room2', targetX: 200, targetY: 200 }
        ],
        npcs: [
          { x: 300, y: 480, type: 'questGiver' }
        ]
      },
      room2: {
        spawn: { x: 200, y: 200 },
        platforms: [
          { x: 0, y: 520, w: 4000 },
          { x: 600, y: 420 }, { x: 900, y: 360 }, { x: 1200, y: 300 },
          { x: 1600, y: 340 }, { x: 2000, y: 380 }
        ],
        enemies: [
          { x: 700, y: 380 },
          { x: 1000, y: 320 },
          { x: 1300, y: 260 }
        ],
        doors: [
          { x: 100, y: 480, targetRoom: 'room1', targetX: 3600, targetY: 200 },
          { x: 3800, y: 480, targetRoom: 'room3', targetX: 200, targetY: 200 }
        ],
        npcs: []
      },
      room3: {
        spawn: { x: 200, y: 200 },
        platforms: [
          { x: 0, y: 520, w: 4000 },
          { x: 500, y: 420 }, { x: 800, y: 360 }, { x: 1100, y: 300 },
          { x: 1400, y: 260 }, { x: 1700, y: 220 }
        ],
        enemies: [
          { x: 600, y: 380 },
          { x: 900, y: 320 }
        ],
        doors: [
          { x: 100, y: 480, targetRoom: 'room2', targetX: 3600, targetY: 200 }
        ],
        npcs: []
      }
    };
  }

  clearRoom() {
    this.platforms.clear(true, true);
    this.enemies.clear(true, true);
    this.doors.clear(true, true);
    this.npcs.clear(true, true);
  }

  loadRoom(roomKey) {
    this.clearRoom();
    const room = this.rooms[roomKey];
    if (!room) return;

    for (let x = 0; x < room.platforms[0].w; x += 64)
      this.platforms.create(x + 32, room.platforms[0].y, 'tile').refreshBody();

    room.platforms.slice(1).forEach(p => {
      this.platforms.create(p.x, p.y, 'tile').refreshBody();
    });

    room.enemies.forEach(e => {
      const enemy = this.enemies.create(e.x, e.y, 'enemy');
      enemy.setCollideWorldBounds(true);
      enemy.body.setBounce(1, 0);
      enemy.body.setVelocityX(Phaser.Math.Between(-60, 60));
      enemy.ai = { type: 'patrol' };
    });

    room.doors.forEach(d => {
      const door = this.doors.create(d.x, d.y, null);
      door.setSize(40, 80).setOffset(-20, -80);
      door.targetRoom = d.targetRoom;
      door.targetX = d.targetX;
      door.targetY = d.targetY;
    });

    room.npcs.forEach(n => {
      const npc = this.npcs.create(n.x, n.y - 24, 'npc');
      npc.type = n.type;
      npc.body.setAllowGravity(false);
    });

    if (this.player) {
      this.player.setPosition(room.spawn.x, room.spawn.y);
      this.player.body.setVelocity(0, 0);
    }
  }

  onDoorOverlap(door) {
    if (!Phaser.Input.Keyboard.JustDown(interactKey)) return;
    this.currentRoom = door.targetRoom;
    this.loadRoom(this.currentRoom);
    this.player.setPosition(door.targetX, door.targetY);
    this.updateQuestUI();
  }

  onNpcOverlap(npc) {
    if (!Phaser.Input.Keyboard.JustDown(interactKey)) return;
    if (npc.type === 'questGiver') this.handleQuestNpc();
  }

  /* ---------------- Quests ---------------- */

  handleQuestNpc() {
    const q = this.playerState.quest;
    if (!q.active && !q.completed) {
      q.active = true;
      q.currentKills = 0;
      this.infoText.setText('Quest accepted: Clear enemies in Room 2.');
    } else if (q.active && !q.completed) {
      this.infoText.setText('Quest in progress: ' + q.currentKills + '/' + q.requiredKills);
    } else if (q.completed) {
      this.infoText.setText('Quest complete! Thank you, little knight.');
    }
    this.updateQuestUI();
  }

  onEnemyHit(enemy) {
    enemy.disableBody(true, true);

    const q = this.playerState.quest;
    if (q.active && !q.completed && this.currentRoom === q.targetRoom) {
      q.currentKills++;
      if (q.currentKills >= q.requiredKills) {
        q.completed = true;
        q.active = false;
        this.infoText.setText('You cleared Room 2! Return to the NPC.');
      } else {
        this.infoText.setText('Enemies defeated: ' + q.currentKills + '/' + q.requiredKills);
      }
      this.updateQuestUI();
    }
  }

  updateQuestUI() {
    const q = this.playerState.quest;
    if (q.completed) {
      this.questText.setText('Quest: Clear Room 2 — COMPLETED');
    } else if (q.active) {
      this.questText.setText(
        'Quest: Clear Room 2 — ' + q.currentKills + '/' + q.requiredKills
      );
    } else {
      this.questText.setText('Quest: Talk to the NPC in Room 1 (press C near them).');
    }
  }

  /* ---------------- Movement / Combat ---------------- */

  handleMovement(dt) {
    const speed = 260;
    const body = this.player.body;

    if (this.playerState.isDashing) return;

    if (cursors.left.isDown) {
      body.setVelocityX(-speed);
      this.playerState.facing = -1;
      this.player.setFlipX(true);
    } else if (cursors.right.isDown) {
      body.setVelocityX(speed);
      this.playerState.facing = 1;
      this.player.setFlipX(false);
    } else {
      body.setVelocityX(0);
    }
  }

  handleJump() {
    const body = this.player.body;
    const onGround = body.blocked.down;

    if (onGround) this.playerState.canDoubleJump = true;

    if (Phaser.Input.Keyboard.JustDown(cursors.up)) {
      if (onGround) body.setVelocityY(-550);
      else if (this.playerState.canDoubleJump) {
        body.setVelocityY(-520);
        this.playerState.canDoubleJump = false;
      }
    }
  }

  handleDash(dt) {
    const body = this.player.body;

    if (this.playerState.dashCooldown > 0)
      this.playerState.dashCooldown -= dt;

    if (!this.playerState.isDashing) {
      if (Phaser.Input.Keyboard.JustDown(dashKey) &&
          this.playerState.dashCooldown <= 0) {

        this.playerState.isDashing = true;
        this.playerState.dashTime = 0.18;
        this.playerState.dashCooldown = 0.6;

        const dashSpeed = 650 * this.playerState.facing;
        body.setVelocityX(dashSpeed);
        body.setVelocityY(0);
      }
    } else {
      this.playerState.dashTime -= dt;
      if (this.playerState.dashTime <= 0)
        this.playerState.isDashing = false;
    }
  }

  handleAttack(dt) {
    if (!this.playerState.isAttacking &&
        Phaser.Input.Keyboard.JustDown(attackKey)) {

      this.playerState.isAttacking = true;
      this.playerState.attackTime = 0.18;

      const offsetX = this.playerState.facing * 30;
      this.attackHitbox.setPosition(this.player.x + offsetX, this.player.y);
      this.attackHitbox.setVisible(true);
    }

    if (this.playerState.isAttacking) {
      this.playerState.attackTime -= dt;

      const offsetX = this.playerState.facing * 30;
      this.attackHitbox.setPosition(this.player.x + offsetX, this.player.y);

      if (this.playerState.attackTime <= 0) {
        this.playerState.isAttacking = false;
        this.attackHitbox.setVisible(false);
      }
    }
  }

  /* ---------------- Utility ---------------- */

  svgTexture(key, svg, w, h) {
    const img = new Image();
    const blob = new Blob([svg], { type: "image/svg+xml" });
    const url = URL.createObjectURL(blob);

    img.onload = () => {
      this.textures.addImage(key, img);
      URL.revokeObjectURL(url);
    };

    img.src = url;
  }
}

new Phaser.Game({
  type: Phaser.AUTO,
  width: GAME_WIDTH,
  height: GAME_HEIGHT,
  physics: {
    default: 'arcade',
    arcade: { gravity: { y: 1400 }, debug: false }
  },
  pixelArt: true,
  backgroundColor: '#05060a',
  scene: [MainScene]
});
</script>

</body>
</html>
