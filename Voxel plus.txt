<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Voxel Dungeon RPG+</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
      background: #000;
      color: #fff;
    }
    #ui {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.5);
      padding: 8px 10px;
      border-radius: 4px;
      font-size: 14px;
    }
    #ui div {
      margin: 2px 0;
    }
    #centerMessage {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 24px;
      text-shadow: 0 0 10px #000;
      z-index: 20;
      pointer-events: none;
    }
    #startOverlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at center, #222 0, #000 60%);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      color: #fff;
      z-index: 30;
    }
    #startOverlay button {
      margin: 6px;
      padding: 8px 14px;
      background: #444;
      border: 1px solid #888;
      color: #fff;
      cursor: pointer;
    }
    #startOverlay button:hover {
      background: #666;
    }
    #minimap {
      position: fixed;
      right: 10px;
      top: 10px;
      width: 150px;
      height: 150px;
      background: rgba(0,0,0,0.7);
      border-radius: 4px;
      border: 1px solid #555;
      z-index: 10;
    }
    #minimap canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>
  <div id="startOverlay">
    <h1>Voxel Dungeon RPG+</h1>
    <p>Select your class to begin</p>
    <div>
      <button data-class="Warrior">Warrior</button>
      <button data-class="Ranger">Ranger</button>
      <button data-class="Mage">Mage</button>
    </div>
    <p style="margin-top:10px;font-size:13px;opacity:0.8;">
      Controls: WASD to move, Mouse to look, LMB light attack, RMB heavy attack, Q fireball
    </p>
  </div>

  <div id="ui" style="display:none;">
    <div id="uiClass">Class: -</div>
    <div id="uiHP">HP: -</div>
    <div id="uiMana">Mana: -</div>
    <div id="uiAttack">Attack: -</div>
    <div id="uiGold">Gold: 0</div>
    <div id="uiScore">Score: 0</div>
    <div id="uiLevel">Level: 1</div>
    <div id="uiState">State: Exploring</div>
  </div>

  <div id="centerMessage"></div>

  <div id="minimap">
    <canvas id="minimapCanvas" width="150" height="150"></canvas>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Basic globals
    let scene, camera, renderer;
    let clock = new THREE.Clock();
    let player = {
      className: "Warrior",
      hp: 100,
      maxHp: 100,
      mana: 50,
      maxMana: 50,
      attack: 10,
      gold: 0,
      score: 0,
      speed: 8,
      position: new THREE.Vector3(),
      velocity: new THREE.Vector3(),
      canAttack: true,
      attackCooldown: 0.4,
      lastAttackTime: 0,
      fireballCost: 10
    };
    let keys = {};
    let pointerLocked = false;
    let yaw = 0;
    let pitch = 0;
    let enemies = [];
    let projectiles = [];
    let dungeonSize = 40;
    let level = 1;
    let gameState = "menu"; // menu, playing, dead, victory

    const ui = {
      root: document.getElementById("ui"),
      class: document.getElementById("uiClass"),
      hp: document.getElementById("uiHP"),
      mana: document.getElementById("uiMana"),
      attack: document.getElementById("uiAttack"),
      gold: document.getElementById("uiGold"),
      score: document.getElementById("uiScore"),
      level: document.getElementById("uiLevel"),
      state: document.getElementById("uiState"),
      centerMessage: document.getElementById("centerMessage")
    };

    const minimapCanvas = document.getElementById("minimapCanvas");
    const minimapCtx = minimapCanvas.getContext("2d");

    // Init Three.js
    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 2, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const ambient = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambient);

      const dir = new THREE.DirectionalLight(0xffffff, 0.6);
      dir.position.set(10, 20, 10);
      scene.add(dir);

      window.addEventListener("resize", onWindowResize);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Simple voxel dungeon floor + walls
    function generateDungeon() {
      // Clear old
      for (let i = scene.children.length - 1; i >= 0; i--) {
        const obj = scene.children[i];
        if (obj.userData && obj.userData.type === "dungeon") {
          scene.remove(obj);
        }
      }

      const floorGeo = new THREE.BoxGeometry(dungeonSize, 1, dungeonSize);
      const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.position.set(0, -0.5, 0);
      floor.userData.type = "dungeon";
      scene.add(floor);

      const wallGeo = new THREE.BoxGeometry(1, 4, dungeonSize);
      const wallMat = new THREE.MeshStandardMaterial({ color: 0x333333 });

      const wall1 = new THREE.Mesh(wallGeo, wallMat);
      wall1.position.set(-dungeonSize / 2, 1.5, 0);
      wall1.userData.type = "dungeon";
      scene.add(wall1);

      const wall2 = wall1.clone();
      wall2.position.set(dungeonSize / 2, 1.5, 0);
      scene.add(wall2);

      const wallGeo2 = new THREE.BoxGeometry(dungeonSize, 4, 1);
      const wall3 = new THREE.Mesh(wallGeo2, wallMat);
      wall3.position.set(0, 1.5, -dungeonSize / 2);
      wall3.userData.type = "dungeon";
      scene.add(wall3);

      const wall4 = wall3.clone();
      wall4.position.set(0, 1.5, dungeonSize / 2);
      scene.add(wall4);

      // Some random pillars
      const pillarGeo = new THREE.BoxGeometry(2, 4, 2);
      const pillarMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
      for (let i = 0; i < 8; i++) {
        const p = new THREE.Mesh(pillarGeo, pillarMat);
        p.position.set(
          (Math.random() - 0.5) * (dungeonSize - 10),
          2,
          (Math.random() - 0.5) * (dungeonSize - 10)
        );
        p.userData.type = "dungeon";
        scene.add(p);
      }
    }

    // Enemies
    function spawnEnemies() {
      enemies.forEach(e => scene.remove(e.mesh));
      enemies = [];

      const enemyCount = 4 + level;
      const enemyGeo = new THREE.BoxGeometry(1.5, 2, 1.5);
      const enemyMat = new THREE.MeshStandardMaterial({ color: 0x992222 });

      for (let i = 0; i < enemyCount; i++) {
        const mesh = new THREE.Mesh(enemyGeo, enemyMat);
        mesh.position.set(
          (Math.random() - 0.5) * (dungeonSize - 6),
          1,
          (Math.random() - 0.5) * (dungeonSize - 6)
        );
        scene.add(mesh);
        enemies.push({
          mesh,
          hp: 30 + level * 5,
          speed: 3 + Math.random() * 1.5,
          alive: true
        });
      }
    }

    // Projectiles (fireballs)
    function spawnFireball() {
      if (player.mana < player.fireballCost) return;
      player.mana -= player.fireballCost;

      const geo = new THREE.SphereGeometry(0.3, 8, 8);
      const mat = new THREE.MeshStandardMaterial({ color: 0xff6600, emissive: 0xff3300 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.copy(camera.position);
      scene.add(mesh);

      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);

      projectiles.push({
        mesh,
        dir,
        speed: 20,
        life: 2
      });
    }

    // Input
    function setupInput() {
      document.addEventListener("keydown", e => {
        keys[e.code] = true;
      });
      document.addEventListener("keyup", e => {
        keys[e.code] = false;
      });

      document.addEventListener("mousedown", e => {
        if (!pointerLocked || gameState !== "playing") return;
        if (e.button === 0) {
          lightAttack();
        } else if (e.button === 2) {
          heavyAttack();
        }
      });

      document.addEventListener("contextmenu", e => e.preventDefault());

      document.addEventListener("mousemove", e => {
        if (!pointerLocked) return;
        const sensitivity = 0.0025;
        yaw -= e.movementX * sensitivity;
        pitch -= e.movementY * sensitivity;
        const maxPitch = Math.PI / 2 - 0.1;
        pitch = Math.max(-maxPitch, Math.min(maxPitch, pitch));
      });

      renderer.domElement.addEventListener("click", () => {
        if (!pointerLocked && gameState === "playing") {
          renderer.domElement.requestPointerLock();
        }
      });

      document.addEventListener("pointerlockchange", () => {
        pointerLocked = document.pointerLockElement === renderer.domElement;
      });

      document.addEventListener("keydown", e => {
        if (e.code === "KeyQ" && gameState === "playing") {
          spawnFireball();
        }
      });
    }

    function lightAttack() {
      const now = performance.now() / 1000;
      if (now - player.lastAttackTime < player.attackCooldown) return;
      player.lastAttackTime = now;
      performMeleeAttack(player.attack);
    }

    function heavyAttack() {
      const now = performance.now() / 1000;
      if (now - player.lastAttackTime < player.attackCooldown * 2) return;
      player.lastAttackTime = now;
      performMeleeAttack(player.attack * 1.8);
    }

    function performMeleeAttack(damage) {
      const range = 3;
      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);

      enemies.forEach(e => {
        if (!e.alive) return;
        const toEnemy = new THREE.Vector3().subVectors(e.mesh.position, camera.position);
        const dist = toEnemy.length();
        if (dist < range) {
          const angle = dir.angleTo(toEnemy.normalize());
          if (angle < Math.PI / 4) {
            e.hp -= damage;
            if (e.hp <= 0) {
              e.alive = false;
              scene.remove(e.mesh);
              player.score += 10;
              player.gold += 5;
            }
          }
        }
      });
    }

    // Movement & physics
    function updatePlayer(dt) {
      const forward = new THREE.Vector3(
        Math.sin(yaw),
        0,
        Math.cos(yaw)
      );
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).negate();

      let move = new THREE.Vector3();
      if (keys["KeyW"]) move.add(forward);
      if (keys["KeyS"]) move.sub(forward);
      if (keys["KeyA"]) move.sub(right);
      if (keys["KeyD"]) move.add(right);

      if (move.lengthSq() > 0) {
        move.normalize();
        move.multiplyScalar(player.speed * dt);
      }

      player.position.add(move);

      // Clamp to dungeon bounds
      const half = dungeonSize / 2 - 2;
      player.position.x = Math.max(-half, Math.min(half, player.position.x));
      player.position.z = Math.max(-half, Math.min(half, player.position.z));

      camera.position.set(player.position.x, 2, player.position.z);
      camera.rotation.set(pitch, yaw, 0);
    }

    function updateEnemies(dt) {
      const playerPos = camera.position.clone();
      enemies.forEach(e => {
        if (!e.alive) return;
        const dir = new THREE.Vector3().subVectors(playerPos, e.mesh.position);
        const dist = dir.length();
        if (dist > 0.1) dir.normalize();
        if (dist > 2) {
          e.mesh.position.addScaledVector(dir, e.speed * dt);
        } else {
          // Damage player
          player.hp -= 10 * dt;
          if (player.hp <= 0 && gameState === "playing") {
            player.hp = 0;
            onPlayerDeath();
          }
        }
      });
    }

    function updateProjectiles(dt) {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.mesh.position.addScaledVector(p.dir, p.speed * dt);
        p.life -= dt;
        if (p.life <= 0) {
          scene.remove(p.mesh);
          projectiles.splice(i, 1);
          continue;
        }

        // Hit enemies
        enemies.forEach(e => {
          if (!e.alive) return;
          const dist = e.mesh.position.distanceTo(p.mesh.position);
          if (dist < 1.5) {
            e.hp -= player.attack * 1.5;
            if (e.hp <= 0) {
              e.alive = false;
              scene.remove(e.mesh);
              player.score += 12;
              player.gold += 6;
            }
            scene.remove(p.mesh);
            projectiles.splice(i, 1);
          }
        });
      }
    }

    // Minimap
    function drawMinimap() {
      minimapCtx.fillStyle = "#000";
      minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);

      const scale = minimapCanvas.width / dungeonSize;
      const centerX = minimapCanvas.width / 2;
      const centerY = minimapCanvas.height / 2;

      // Player
      minimapCtx.fillStyle = "#00ff00";
      minimapCtx.beginPath();
      minimapCtx.arc(
        centerX + player.position.x * scale,
        centerY + player.position.z * scale,
        4,
        0,
        Math.PI * 2
      );
      minimapCtx.fill();

      // Enemies
      minimapCtx.fillStyle = "#ff0000";
      enemies.forEach(e => {
        if (!e.alive) return;
        minimapCtx.fillRect(
          centerX + e.mesh.position.x * scale - 2,
          centerY + e.mesh.position.z * scale - 2,
          4,
          4
        );
      });
    }

    // UI
    function updateUI() {
      ui.class.textContent = "Class: " + player.className;
      ui.hp.textContent = "HP: " + Math.round(player.hp) + " / " + player.maxHp;
      ui.mana.textContent = "Mana: " + Math.round(player.mana) + " / " + player.maxMana;
      ui.attack.textContent = "Attack: " + player.attack.toFixed(1);
      ui.gold.textContent = "Gold: " + player.gold;
      ui.score.textContent = "Score: " + player.score;
      ui.level.textContent = "Level: " + level;
      ui.state.textContent = "State: " + (gameState === "playing" ? "Exploring" : gameState);
    }

    function showCenterMessage(msg, duration = 2) {
      ui.centerMessage.textContent = msg;
      if (duration > 0) {
        setTimeout(() => {
          if (ui.centerMessage.textContent === msg) {
            ui.centerMessage.textContent = "";
          }
        }, duration * 1000);
      }
    }

    function onPlayerDeath() {
      gameState = "dead";
      ui.state.textContent = "State: Dead";
      showCenterMessage("You Died! Refresh to restart.", 0);
      document.exitPointerLock?.();
    }

    function checkLevelClear() {
      const alive = enemies.some(e => e.alive);
      if (!alive && gameState === "playing") {
        level++;
        showCenterMessage("Level cleared! Advancing...", 2);
        setTimeout(() => {
          generateDungeon();
          spawnEnemies();
        }, 1500);
      }
    }

    // Class selection
    function applyClass(className) {
      player.className = className;
      if (className === "Warrior") {
        player.maxHp = 140;
        player.hp = 140;
        player.maxMana = 40;
        player.mana = 40;
        player.attack = 12;
        player.speed = 7;
      } else if (className === "Ranger") {
        player.maxHp = 100;
        player.hp = 100;
        player.maxMana = 60;
        player.mana = 60;
        player.attack = 10;
        player.speed = 9;
      } else if (className === "Mage") {
        player.maxHp = 80;
        player.hp = 80;
        player.maxMana = 100;
        player.mana = 100;
        player.attack = 9;
        player.speed = 8;
      }
    }

    // Game loop
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      if (gameState === "playing") {
        updatePlayer(dt);
        updateEnemies(dt);
        updateProjectiles(dt);
        drawMinimap();
        checkLevelClear();
      }

      updateUI();
      renderer.render(scene, camera);
    }

    // Start flow
    function startGame(selectedClass) {
      applyClass(selectedClass);
      document.getElementById("startOverlay").style.display = "none";
      ui.root.style.display = "block";
      gameState = "playing";
      player.position.set(0, 0, 0);
      yaw = 0;
      pitch = 0;
      generateDungeon();
      spawnEnemies();
      showCenterMessage("Level " + level, 2);
      renderer.domElement.requestPointerLock();
    }

    // Boot
    initThree();
    setupInput();
    animate();

    // Start overlay buttons
    document.querySelectorAll("#startOverlay button").forEach(btn => {
      btn.addEventListener("click", () => {
        const cls = btn.getAttribute("data-class");
        startGame(cls);
      });
    });
  </script>
</body>
</html>
